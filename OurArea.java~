import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

public class OurArea extends Area implements KeyListener {
  
  /*
  // The trees that are scattered around the area.
  Tree trees[];
  
  // The area tile map, with each tile represented as an integer.
  int tiles[][];
  
  // The tile values for grass (0) and stone (1) tiles.
  int grass;
  int stone;
  
  // The number of tiles on the x-axis, and y-axis.
  int numTilesX;
  int numTilesY;
  
  // The maximum position of a tree on the x-axis and y-axis.
  // Note: The minimum is simply (0, 0).
  double maxTreeX;
  double maxTreeY;
  */
	
  private int oldX, oldY; 
  // The constructor for OurArea. It takes in a parameter for the
  // number of trees to place in the area.
  public OurArea(int numberOfTrees) 
  {
    super(); // A magic function. Ignore this.
    
    //* Exercise #1. Setup the tree objects at random locations.
    
    //Sets the size of the tree array (sets every thing to null)
   trees = new Tree[numberOfTrees];
   
   /*actually initializes each place to hold a random value
    * Guarantees to be placed within the screen by multiplying by 
    * maximum position that it could be at 
    * remember what Math.random returns and think about how this makes 
    * it true
    * */ 
    for(int i = 0; i < trees.length; i++)
   {
     trees[i] = new Tree( (int)(Math.random() * maxTreeX), 
                         (int) (Math.random() *  maxTreeY)); 
     
   }
   
    //*/
    
    //* Exercise #3. Initialize the tiles
   
   //Sets the size of the tiles array 
    tiles = new int[numTilesX][numTilesY];
    
    //actually initializes the tiles to hold a value 
    for(int i = 0; i < numTilesX; i++)
    {
      for(int j = 0; j <numTilesY; j++)
      {
        // Example: Default to grass everywhere.
        tiles[i][j] = grass; 
     // Example: A checker board pattern of stones
        //if the x and y position of the tile are both even draw grass 
        //otherwise place a stone (draw it out on a piece of paper to see
        if (i % 2 == j % 2) 
        {
          tiles[i][j] = grass;
        } 
        else
        {
          tiles[i][j] = stone;
          //print statement for debugging 
         // System.out.println("Putting a stone at " + i + "," +j); 
        } //end of else 
      }//end of inner for loop 
    }//end of outer for loop 
    
        
 
        
    // Example: Draw two stones at specific locations(top left, and bottom right).
   // tiles[0][0] = stone;
   // tiles[numTilesX-1][numTilesY-1] = stone; //Why do I have to subtract one to place it in the bottom right corner(think about how we index arrays)? 
        
        
        
    
  
    
    //*/
  }
  
  // This function must draw each tree to the screen.
  // Does not need tiles (try commenting out the drawGrass function and see what happens)
  protected void drawTrees() {
    //* Exercise #2. Draw the trees.
    for(int i = 0; i < trees.length; i++)
    {
      drawTree(i); 
    }
    //*/
  }
  
  
  protected void drawTiles() 
  {
    //* Exercise #4. Draw the tiles.
    
    /*Need a nested for loop to go through the rows 
     * and the columns
     * */ 
    for (int i = 0; i < numTilesX; i++) 
    {
      for (int j = 0; j < numTilesY; j++) 
      {
        if (tiles[i][j] == grass) 
        {
          drawGrass(i, j);
        } 
        else if(tiles[i][j] == stone) 
        {
          
          drawStone(i, j);
        }
      }
    }
    //*/
  }
  
  
//Method that will continually run and call move method on first tree in array. 
public void start() 
{
	while(true) 
	{ 
		try 
		{ 
			Thread.sleep(16);
			oldX = trees[0].get_x();
			oldY = trees[0].get_y();
			trees[0].move();
			trees[1].move();
			if(tiles[trees[0].get_x()][trees[0].get_y()] == stone)
				trees[0].set_location(oldX, oldY);
			//System.out.println("Tree's position is currently " + trees[0].get_x() + "," + trees[0].get_y());
			repaint(); 
		}catch(Exception e) 
		{ 
		e.printStackTrace(); 
		} 
	} 
	
}

public void keyPressed(KeyEvent e) {
	int key=e.getKeyCode(); 
	if(key==KeyEvent.VK_W) 
		trees[0].setSpeedY(-1); 
	if(key==KeyEvent.VK_S) 
		trees[0].setSpeedY(1); 
	if(key==KeyEvent.VK_A) 
		trees[0].setSpeedX(-1); 
	if(key==KeyEvent.VK_D) 
		trees[0].setSpeedX(1);
	
	switch(key)
	{
	case KeyEvent.VK_UP:
		trees[1].setSpeedY(-1); 
		break;
	case KeyEvent.VK_DOWN: 
		trees[1].setSpeedY(1);
		break;
	case KeyEvent.VK_LEFT:
		trees[1].setSpeedX(-1);
		break;
	case KeyEvent.VK_RIGHT:
		trees[1].setSpeedX(1);
		break; 
	}
}

public void keyReleased(KeyEvent e) {
	int key=e.getKeyCode(); 
	switch(key)
	{
	case KeyEvent.VK_W:
	case KeyEvent.VK_S:
	case KeyEvent.VK_A:
	case KeyEvent.VK_D:
		trees[0].setSpeedX(0);
		trees[0].setSpeedY(0);
		break; 
	case KeyEvent.VK_UP:
	case KeyEvent.VK_DOWN:
	case KeyEvent.VK_LEFT:
	case KeyEvent.VK_RIGHT:
		trees[1].setSpeedX(0);
		trees[1].setSpeedY(0);
		break; 
	}
	
	
	 
}


@Override
public void keyTyped(KeyEvent e) {
	// TODO Auto-generated method stub
	
}
  

}
